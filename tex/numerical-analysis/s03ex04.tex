\documentclass[12pt]{amsart}

\usepackage{amssymb,amsmath,amsthm, amsfonts}
%\usepackage[german]{babel}
\usepackage[latin1]{inputenc}
\usepackage[all,knot]{xy}
\usepackage{graphicx}
\usepackage{tikz}

\usepackage[numbered,framed]{matlab-prettifier}

\oddsidemargin = 0.5cm 
\evensidemargin = 0.5cm 
\textwidth = 16cm
\headsep = -1cm
\textheight = 22.3cm

\newtheorem{case}{Case}
\newcommand{\caseif}{\textnormal{if }}
\newcommand{\leg}[2]{\genfrac{(}{)}{}{}{#1}{#2}}
\newcommand{\bfrac}[2]{\genfrac{}{}{}{0}{#1}{#2}}
\newcommand{\sm}[4]{\left(\begin{smallmatrix}#1&#2\\ #3&#4 \end{smallmatrix} \right)}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem*{conjecture}{\bf Conjecture}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
%\renewcommand{\theequation}{\thesection.\arabic{equation}}
\renewcommand{\thetheorem}{\thesection.\arabic{theorem}}
\theoremstyle{definition}
\newtheorem{exercise}{Exercise}
\newtheorem{problem}{Problem}
\newtheorem{bonus_exercise}[exercise]{Exercise*}
\newtheorem*{solution}{Solution}
\newtheorem*{answer}{Answer}
\newtheorem*{claim}{Claim}
\theoremstyle{remark}
\newtheorem*{theoremno}{{\bf Theorem}}
\newtheorem*{remark}{Remark}
\newtheorem*{hint}{Hint}
\newtheorem*{example}{Example}
\numberwithin{theorem}{section}
% \numberwithin{equation}{section}
\newtheorem*{theorem*}{Theorem}

\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\ceil}{\operatorname{ceil}}

\begin{document}

\noindent
Name: Alexandre Cordonnier \\
SCIPER: 310692 \\
\begin{center}
Exercises - Week 3 \\
Numerical analysis MATH-250 \\ Spring 2021
\end{center}
\stepcounter{problem}
\stepcounter{problem}
\stepcounter{problem}
\begin{problem}
	\begin{enumerate}
		\item[(a)]
		We create function \verb|myexp|, file \verb|myexp.m| :
		\lstinputlisting[style=Matlab-editor]{myexp.m}
		We use \verb|temp| variable to avoid unnecessary operations, such as computing it twice, one in the \verb|while| condition, and one when addind it to the partial sum. Similarly, we use variable \verb|p| and \verb|f| to avoid having to compute \verb|x^i| and \verb|i!| at each iteration.
		\item[(b)]
		We compute the relative error between the output of functions \verb|myexp| and built-in \verb|exp|, at \verb|x=-20| and \verb|x=-0.5|, file \verb|main.m|:
		\lstinputlisting[style=Matlab-editor]{main.m}
		Running this file displays:
		\begin{verbatim}
		    Relative error between myexp(-20) and exp(-20):
		        1.978070
		    Relative error between myexp(-0.5) and exp(-0.5):
		        1.830448e-16
		\end{verbatim}
		We notice that \verb|myexp| is very accurate for \verb|x=-0.5|, but is very inaccurate for \verb|x=-20|.
		We call here $n_x\in\N$ to be the closest integer to $|x|$. For $x<-1$, $\exp(x)\in(0,e^{-1})$ with $e^{-1}\approx 0.3679$, so the result is expected to be rather small. But as for $x<1$, $x^{n_x}/n_x!$ is rather big (it's actually the biggest term of the sum in magnitude), and as the terms are alternating, the terms in the summation are expected to cancel each other to some extend, leaving room for errors.\\ 
		When computing $x^{n_x}/n_x!$ term in the sum, we get $(1+\delta)\cdot x^{n_x}/n_x!$ for some $|\delta|<u$. So when we are adding the few terms next to the $n_x$'s term, the operations are accurate at most up to about $\delta\cdot x^{n_x}/n_x!$ precision. But when we're adding to that the last few terms of the sum (which are rather small), they are most likely smaller than $\delta\cdot x^{n_x}/n_x!$.\\
		So the precision errors made when adding the biggest (in magnitude) term of the sum basically mask the contributions of the terms smaller than $\delta\cdot x^{n_x}/n_x!$, which are important as the result is expected to be small (for $x<1$).\\
		We can try to verify this on some examples, for instance by computing the result of \verb|myexp(-50)| and its expected value \verb|eps * (-50)^50 / factorial(50)| : 
		\begin{verbatim}
		    Real value of exp(-50):
		        1.928750e-22
		    Expected range for the result of exp(-50):
		        64843.368828
		    Computation of myexp(-50):
		        69315.001419
		\end{verbatim}
		We see our guess was correct.
		\item[(c)]
		We create function \verb|myexp2|, file \verb|myexp2.m| :
		\lstinputlisting[style=Matlab-editor]{myexp2.m}
		We compute \verb|m| to be the smallest non-negative integer such that $$|x|\cdot 2^{-m}\leq 1 \iff 2^{-m}\leq|x|^{-1}\iff m\geq \log_2|x|$$, that is $m = \max(0, \ceil(\log_2|x|))$.\\ 
		We then use the neat identity that $\exp(x) = \left(\exp\left(\frac{x}{2^m}\right)\right)^{2^m}$.
		We can now test this safer approach to compute $e^x$ (file \verb|main.m|):
		\lstinputlisting[style=Matlab-editor]{main2.m}
		which outputs
		\begin{verbatim}
		    Relative error for i=-20:    1.103627919703319e-14
		    Relative error for i=-18:    6.300267804982673e-15			
		    Relative error for i=-16:    5.292301207368676e-15			
		    Relative error for i=-14:    1.527968176795108e-15			
		    Relative error for i=-12:    3.170749425074150e-15			
		    Relative error for i=-10:    5.373256965054097e-15			
		    Relative error for i=-8:     2.585568900510926e-15			
		    Relative error for i=-6:     1.574634147652906e-15			
		    Relative error for i=-4:     1.515403081718387e-15			
		    Relative error for i=-2:     6.152625158459809e-16
		\end{verbatim}
		which is much more satisfying.
	\end{enumerate}
\end{problem}

\end{document}